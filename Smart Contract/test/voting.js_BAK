var Voting = artifacts.require("./Voting.sol");

contract('Voting', function (accounts) {
    let catchRevert = require("./exceptions.js").catchRevert;
    let catchRevertWithReason = require("./exceptions.js").catchRevertWithReason;
    var meta;

    it("should give a vote and check if voted", function () {
        return Voting.deployed().then(function (instance) {
            meta = instance;
            return meta.castVote("voter1", 3, {from: accounts[0]});
        }).then(function () {
            return meta.getVotersAnswer.call({from: accounts[0]});
        }).then(function (vote) {
            assert.equal(vote.valueOf(), 3, "Incorrect voters answer returned");
        }).then(function () {
            return meta.getVotersName.call({from: accounts[0]});
        }).then(function (vote) {
            assert.equal(vote.valueOf(), "voter1", "Incorrect voters name returned");
        })
    });
    it("should not allow second vote", function () {
        return Voting.deployed().then(function (instance) {
            meta = instance;
            return meta.castVote("voter2", 1, {from: accounts[1]});
        }).then(async function () {
            await catchRevertWithReason(meta.castVote("voter2", 1, {from: accounts[1]}), "This adress has already voted. Vote denied.");
        });
    });
    it("should not allow voter name with too less chars", function () {
        return Voting.deployed().then(async function (instance) {
            meta = instance;
            await catchRevertWithReason(meta.castVote("vo", 1, {from: accounts[2]}), "Name of voter is too short (at least 3 chars).");
        });
    });
    it("should not allow voting on not allowed answer", function () {
        return Voting.deployed().then(async function (instance) {
            meta = instance;
            await catchRevertWithReason(meta.castVote("voter3", 9999, {from: accounts[3]}), "Choice must be less than contract configured numberOfChoices.");
        });
    });
    it("should allow to vote on index 0", function () {
        return Voting.deployed().then(function (instance) {
            meta = instance;
            return meta.castVote("voter3", 0, {from: accounts[4]});
        }).then(function () {
            return meta.getVotersAnswer.call({from: accounts[4]});
        }).then(function (vote) {
            assert.equal(vote.valueOf(), 0, "Incorrect vote returned");
        })
    });
    // it("should not allow to vote on first out of bounds index 4 (allowed: 0..3)", function () {
    //     return Voting.deployed().then(async function (instance) {
    //         meta = instance;
    //         await catchRevert(meta.castVote("vo", 4, {from: accounts[3]}));
    //     });
    // });
    // it("should give all vote counts back", function () {
    //     return Voting.deployed().then(function (instance) {
    //         meta = instance;
    //         return meta.getAnswerCounts.call({from: accounts[0]});
    //     }).then(function (answerCount) {
    //         assert.equal(answerCount[0].toNumber(), 1, "Incorrect voter count returned");
    //         assert.equal(answerCount[1].toNumber(), 1, "Incorrect voter count returned");
    //         assert.equal(answerCount[2].toNumber(), 0, "Incorrect voter count returned");
    //         assert.equal(answerCount[3].toNumber(), 1, "Incorrect voter count returned");
    //     })
    // });
});
